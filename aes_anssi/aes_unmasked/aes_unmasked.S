#if defined(__CC_ARM)       // Keil
    #define CODESECT AREA     MYCODE, CODE, READONLY, ALIGN=2
    #define DATASECT AREA     MYDATA, DATA, READWRITE
    #define LABEL
	#define MYBYTE DCB
	#define MYWORD DCW
#elif defined (__GNUC__)    // GCC
    #define THUMB .thumb
    #define CODESECT .section .text
	#define DATASECT .section .data
    #define EXPORT .global
    #define PROC :
    #define LABEL :
    #define ENDP
    #define END
	#define MYBYTE .byte
	#define MYWORD .word
	.syntax unified
	.cpu cortex-m4
	.fpu softvfp
	.thumb
    .syntax unified
    #define ALIGN(a) .align a
    #define LOCAL    .local
#endif


	DATASECT
LOCAL state, key_state, sbox, xtime, rcon

ALIGN(4)
state LABEL 	MYBYTE 		0x09,0xe9,0xef,0xd4,0x77,0x2e,0xb1,0x68,0xd6,0xd1,0xd3,0x9a,0x38,0xae,0xb3,0x4f

key_state LABEL
	MYBYTE 	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	MYBYTE 	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	MYBYTE 	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	MYBYTE 	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	MYBYTE 	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	MYBYTE 	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	MYBYTE 	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	MYBYTE 	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	MYBYTE 	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	MYBYTE 	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	MYBYTE 	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF

LOCAL sbox
sbox LABEL
    MYBYTE    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76
    MYBYTE    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0
    MYBYTE    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15
    MYBYTE    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75
    MYBYTE    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84
    MYBYTE    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf
    MYBYTE    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8
    MYBYTE    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2
    MYBYTE    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73
    MYBYTE    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb
    MYBYTE    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79
    MYBYTE    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08
    MYBYTE    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a
    MYBYTE    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e
    MYBYTE    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf
    MYBYTE    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16


// table representing the field multiplication by 2
LOCAL xtime
xtime LABEL
	MYBYTE 0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e
	MYBYTE 0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e
	MYBYTE 0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e
	MYBYTE 0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e
	MYBYTE 0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e
	MYBYTE 0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe
	MYBYTE 0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde
	MYBYTE 0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe
	MYBYTE 0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05
	MYBYTE 0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25
	MYBYTE 0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45
	MYBYTE 0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65
	MYBYTE 0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85
	MYBYTE 0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5
	MYBYTE 0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5
	MYBYTE 0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5


	CODESECT
	EXPORT anssi_aes_unmasked

LOCAL rcon
rcon LABEL
	MYBYTE    0x01,0x00,0x00,0x00
	MYBYTE    0x02,0x00,0x00,0x00
	MYBYTE    0x04,0x00,0x00,0x00
	MYBYTE    0x08,0x00,0x00,0x00
	MYBYTE    0x10,0x00,0x00,0x00
	MYBYTE    0x20,0x00,0x00,0x00
	MYBYTE    0x40,0x00,0x00,0x00
	MYBYTE    0x80,0x00,0x00,0x00
	MYBYTE    0x1b,0x00,0x00,0x00
	MYBYTE    0x36,0x00,0x00,0x00

/************************************************************************
* Add_roundkey : Xor between state and the derivated key
*
* r3 = @state
* r8 = @key (different for each round)
* r4, r5, r6, r7, r8 = local variables
*/

Add_roundkey LABEL					//r3 = @state ; not used ; r0, r1, r2
/*	ldm r3, {r6, r7, r9, r10}		// This code uses less cycles but need too much registers
	ldm r8, {r4, r5, r11, r12}
	eor r4,r6
	eor r5,r7
	eor r11,r9
	eor r12,r10
	stm r3, {r4, r5, r11, r12}*/
	ldm r3, {r6, r7}
	ldm r8, {r4, r5}
	eor r4,r6
	eor r5,r7
	stm r3, {r4, r5}

	add r3, #0x8
	add r8, #0x8
	ldm r3, {r6, r7}
	ldm r8, {r4, r5}
	eor r4,r6
	eor r5,r7
	stm r3, {r4, r5}

	sub r3, #0x8
    bx  LR


/************************************************************************
* SubBytes : It modifies only state
* r3 = @state
* r8 = @sbox
* r5 = internal counter
* r4, r7 = local variables
*/

SubBytes LABEL
   mov r5, #0x10
   ldr r8, =sbox
loop_SubBytes LABEL
   ldr r4,[r3]
   and r4, #0xFF
   add r4, r8
   ldrb r7, [r4]
   strb r7, [r3],#01
   subs r5,#1
   BNE  loop_SubBytes
   sub r3, #0xF
   bx LR



/************************************************************************
* ShiftRows : It modifies only state
* r3 = @state
* r4, r5, r6, r7 = local variables
*
*/

ShiftRows LABEL						// r3 = @state +1 not used : r8, r9, r10, r11, r12
	ldr r4, [r3], #0x4				// load s10
	ldr r5, [r3], #0x4				// load s11
	ldr r6, [r3], #0x4				// load s12
	ldr r7, [r3]					// load s13

	//ldm r3, {r4, r5, r6, r7} ne fonctionne pas --> fault handler
	sub r3, #0xC

	strb r5,[r3], #0x4
	strb r6,[r3], #0x4
	strb r7,[r3], #0x4
	strb r4,[r3], #0x4

	sub r3, #0xF
	ldr r4, [r3], #0x4
	ldr r5, [r3], #0x4
	ldr r6, [r3], #0x4
	ldr r7, [r3]

	sub r3, #0xC
	strb r6,[r3], #0x4
	strb r7,[r3], #0x4
	strb r4,[r3], #0x4
	strb r5,[r3]

	sub r3, #0xB
	ldrb r4, [r3], #0x4
	ldrb r5, [r3], #0x4
	ldrb r6, [r3], #0x4
	ldrb r7, [r3]

	sub r3, #0xC
	strb r7,[r3], #0x4
	strb r4,[r3], #0x4
	strb r5,[r3], #0x4
	strb r6,[r3]

	sub r3, #0xF
	bx LR

/************************************************************************
* MixColumns: It modifies only state
*
* r3 = @state
* r5 = internal counter
* r4, r7, r8, r10, r11 = local variables
*
*/

MixColumns LABEL 				//r3 = @state ; r6 used in lnot used : r12
    push {LR}
	mov r5,#0x4					// ctr (+1 for each column)
MixColumns_Loop LABEL			// for each column
	ldrb r8, [r3], #0x1			// a1
	eor r4, r8, #0x0			//

	ldrb r11, [r3], #0x1		// a2
	eor r4, r4, r11

	ldrb r10, [r3], #0x1		// a3
	eor r4, r4, r10

	ldrb r7, [r3]				// a4
	eor r4, r4, r7
	sub r3, #0x3				// come back to the first byte adr

	push {r7}

	eor r7,r8,r11				// a1+a2
	bl Mult	 					// 2*(a1+a2)
	eor r7, r8					// 2*(a1+a2)+a1
	eor r7,r4					// 2*(a1+a2)+a1+t
	strb r7, [r3], #0x1

	eor r7, r11, r10				// a2+a3
	bl Mult						// 2*(a2+a3)
	eor r7, r11					// 2*(a2+a3)+a2
	eor r7, r4					// 2*(a2+a3)+a2+t
	strb r7, [r3], #0x1

	pop {r11}
	eor r7, r10, r11			// a3+a4
	bl Mult						// 2*(a3+a4)
	eor r7, r10					// 2*(a3+a4)+a3
	eor r7, r4					// 2*(a3+a4)+a3+t
	strb r7, [r3], #0x1

	eor r7, r8, r11				// a1+a4
	bl Mult						// 2*(a1+a4)
	eor r7, r11					// 2*(a1+a4)+a4
	eor r7, r4					// 2*(a1+a4)+a4+t
	strb r7, [r3], #0x1

	subs r5,#0x1
	bne MixColumns_Loop
	subs r3,#0x10
	pop {PC}




/************************************************************************
* Multiplication by 2 modulo a polynomial
* content of r7 is multiplied
* r6 = xtime @
*/

/* Previous version vulnerable to timing attacks */
/*
Mult LABEL						// multiply a byte r7 by 2
	lsl r7,#0x1
	and r6, r7, #0xFFFFFF00
	cmp r6, #0x100
	bne Not_Carry_Mul			// cause it is a plynomial mult
	eor r7,#0x1b
	and r7,#0xff				// delete the "carry"
Not_Carry_Mul LABEL
    bx LR
*/

Mult LABEL						// multiply a byte r7 by 2 and store in r7
	add r7, r6
	ldrb r7, [r7]
    bx LR



/************************************************************************
* Load_data : Load data from the @ r4 and store it in the @ r7
* r5, r6, r10, r11 = locale variables
*
*/

Load_data LABEL
	ldm r4, {r5, r6, r10, r11}
	stm r7, {r5, r6, r10, r11}
	bx  LR



/************************************************************************
* KeyExpansion (key schedule) : For each round, it generates a derivated key
* r2 = @rcon
* r6 = @key
* r5 = internal counter
* r10 = @sbox
* r4, r7, r8, r11 = local variables
*
*/

KeyExpansion LABEL					//  R6 = current key state // r10 = rcon index not used :r11
	push {r2}
	mov r5, #0x4
	add r6, #0xC
	ldr r4, [r6]
	mov r7, r4
	and r7, #0xFF
	lsl r7, #0x18					// the last byte has to be in the first position in the word
	lsr r4, #0x8
	eor r4, r7
	add r11, r6, #0x4
	str r4,[r11]
	ldr r10, =sbox
loop_SubBytes_ke LABEL
   ldr r4,[r11]
   and r8, r4, #0xFF
   add r8, r10
   ldrb r4, [r8]
   strb r4, [r11]  					// contenu de position
   add r6, #01						// move to the next bytes
   add r11, #01
   subs r5, #1
   BNE loop_SubBytes_ke
   mov r5, #0x3
   sub r11, #0x4					// current word key value adr
   ldr r4, [r11]					// load current key word
   ldr r8, [r2]  					// load rcon value
   eor r4, r8
   sub r2, r11, #0x10				// first column adr
   ldr r8, [r2]						// load column i-4
   eor r4, r8						// xor avec la premi�re colo avant stockage
   str r4, [r11]					// store xor in current key word
   sub r7, r11, #0xc
Xor_Exp_Loop LABEL
   ldr r8, [r7], #0x4           	// adr previous column
   eor r4, r8
   add r11, #0x4					// adr to store : new current addr
   str r4, [r11]					// store value
   subs r5, #0x1
   BNE Xor_Exp_Loop
   pop {r2}
   bx LR




/************************************************************************
*AES :
*r0 = @message in the first place then global variable for round number
*r1 = @key in the first place
*r2 = @result in the first place then global variable for @rcon
*r3 = global variable for @state
*r4, r6, r7, r8 = local variables
*/

anssi_aes_unmasked LABEL
    PUSH.W  {R4-R11,LR}  		// Preserve Registers R4-R11 on the stack
	push {r2}
	ldr r3, =state				// adr store
	mov r4, r0					// adr load
	mov r7, r3
	bl Load_data 				// load message

	mov r4, r1
	ldr r7, =key_state
	bl Load_data 				// load key

	ldr r2, =rcon				// rcon value
	mov r8, r7					// key_state @
	bl Add_roundkey
	mov r0, #0xA				// from here r0 = round ctr
  ldr r1, =key_state
Round_Loop LABEL
	bl SubBytes
	bl ShiftRows
	cmp r0, #0x1				// The last round do not process MixColumns
	beq No_Mix
        ldr r6, =xtime
	bl MixColumns
No_Mix LABEL
	mov r6, r1
	bl KeyExpansion
	add r1,  #0x10
	mov r8,r1
	bl Add_roundkey
	add r2, #0x4
	subs r0, #0x1
	bne Round_Loop
	pop {r2}
	mov r7, r2
	mov r4, r3
	bl Load_data				// load state in result
    POP.W   {R4-R11,PC}         //Restore Registers R4-R11 from the stack
	END
